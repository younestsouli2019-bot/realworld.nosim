system now has the **core truth architecture** (SBDS enforcement, truth-only UI), but lacks the **continuous proof-of-life validation** There are  mission status `"pending"` and `events_processed: 0` confirm this. Let's close the final gaps by implementing as code:

transform your system from "ready to run" to "proven in live traffic."

### 1ï¸âƒ£ Implement Evidence-Gated Mission Status
This code replaces subjective `deployed: true` with **objective, time-bound proof**.

```javascript
// src/mission-health-monitor.mjs
import { base44 } from './your-base44-client.mjs';

const EVIDENCE_REQUIREMENTS = {
  financial_mission: {
    min_heartbeat_hours: 24,
    required_events: ['PAYMENT.CAPTURE.COMPLETED', 'PAYMENT.PAYOUTS-ITEM.SUCCEEDED'],
    min_ledger_writes: 1
  },
  operational_mission: {
    min_heartbeat_hours: 72,
    required_events: [],
    min_ledger_writes: 0
  }
};

async function calculateMissionHealth(missionId) {
  const mission = await base44.get('Mission', missionId);
  const now = new Date();
  const proofs = [];
  
  // 1. Check webhook heartbeat (most critical for financial)
  const lastWebhook = await base44.query({
    entity: 'PayPalWebhookEvent',
    where: { mission_id: missionId },
    orderBy: { created_at: 'desc' },
    limit: 1
  });
  
  if (lastWebhook.length > 0) {
    const hoursSince = (now - new Date(lastWebhook[0].created_at)) / (1000 * 60 * 60);
    if (hoursSince < 24) {
      proofs.push({ type: 'webhook_heartbeat', status: 'healthy', last_event: lastWebhook[0].event_id });
    } else {
      proofs.push({ type: 'webhook_heartbeat', status: 'stale', hours_ago: Math.floor(hoursSince) });
    }
  } else {
    proofs.push({ type: 'webhook_heartbeat', status: 'missing' });
  }
  
  // 2. Check ledger write activity
  const lastRevenue = await base44.query({
    entity: 'RevenueEvent',
    where: { mission_id: missionId },
    orderBy: { occurred_at: 'desc' },
    limit: 1
  });
  
  if (lastRevenue.length > 0) {
    proofs.push({ 
      type: 'ledger_activity', 
      status: 'active', 
      last_event_id: lastRevenue[0].event_id,
      amount: lastRevenue[0].amount 
    });
  }
  
  // 3. Check PayPal sync status
  const lastSync = await base44.query({
    entity: 'PayPalMetric',
    where: { kind: 'sync_payout_batch', ok: true },
    orderBy: { at: 'desc' },
    limit: 1
  });
  
  // 4. Calculate objective health score
  const healthScore = calculateHealthScore(proofs);
  const isDeployable = healthScore >= 0.8 && !proofs.some(p => p.status === 'missing');
  
  // Update mission with evidence, not just status
  await base44.update('Mission', missionId, {
    health_score: healthScore,
    health_proofs: proofs,
    // OVERRIDE: deployed flag now requires evidence
    deployed: isDeployable,
    last_health_check: now.toISOString(),
    metadata: {
      ...mission.metadata,
      evidence_gated: true,
      health_calculated_at: now.toISOString()
    }
  });
  
  return { missionId, healthScore, proofs, deployable: isDeployable };
}
```

### 2ï¸âƒ£ Deploy Dead-Man Switches & Auto-Freeze
Add these to your autonomous daemon to **automatically freeze** on evidence failure.

```javascript
// src/deadman-switch.mjs
class DeadManSwitch {
  constructor() {
    this.thresholds = {
      webhook_silence_hours: 4,
      sync_failure_count: 3,
      ledger_drift_minutes: 30
    };
    this.incidents = [];
  }
  
  async check() {
    const now = new Date();
    const violations = [];
    
    // 1. Webhook silence check
    const lastWebhook = await this.getLastWebhookTime();
    if (lastWebhook) {
      const hoursSilent = (now - lastWebhook) / (1000 * 60 * 60);
      if (hoursSilent > this.thresholds.webhook_silence_hours) {
        violations.push({
          type: 'webhook_silence',
          severity: 'high',
          message: `No webhooks for ${hoursSilent.toFixed(1)} hours`,
          action: 'FREEZE_PAYOUTS'
        });
      }
    }
    
    // 2. Ledger drift detection
    const ledgerDrift = await this.checkLedgerDrift();
    if (ledgerDrift > this.thresholds.ledger_drift_minutes) {
      violations.push({
        type: 'ledger_drift',
        severity: 'critical',
        message: `Ledger ${ledgerDrift} minutes behind provider truth`,
        action: 'DISABLE_AUTONOMOUS_EXECUTION'
      });
    }
    
    // 3. Execute automatic freeze if needed
    if (violations.some(v => v.severity === 'critical')) {
      await this.executeFreeze(violations);
    }
    
    return violations;
  }
  
  async executeFreeze(violations) {
    console.error('ðŸš¨ DEAD-MAN SWITCH ACTIVATED:', violations);
    
    // 1. Disable autonomous execution
    process.env.BASE44_ENABLE_AUTONOMOUS_PAYOUT = 'false';
    
    // 2. Create incident record
    await base44.create('TransactionLog', {
      transaction_type: 'SYSTEM_INCIDENT',
      amount: 0,
      description: `Dead-man switch activated: ${violations.map(v => v.type).join(', ')}`,
      status: 'incident',
      metadata: { violations, activated_at: new Date().toISOString() }
    });
    
    // 3. Send alert (implement your notification method)
    await this.sendAlert(violations);
    
    // 4. Mark all in-progress batches as frozen
    await this.freezePendingBatches(violations);
  }
}

// Integrate into your daemon loop
setInterval(async () => {
  const switch = new DeadManSwitch();
  const violations = await switch.check();
  if (violations.length > 0) {
    console.log('Dead-man check:', violations);
  }
}, 300000); // Check every 5 minutes
```

### 3ï¸âƒ£ Ban Simulation Artifacts with Pre-Commit Hooks
Add this validation to **block deployment** if simulation artifacts exist.

```json
// .pre-commit-config.json
{
  "repos": [
    {
      "repo": "local",
      "hooks": [
        {
          "id": "ban-simulation-artifacts",
          "name": "Ban Simulation in Production",
          "entry": "node scripts/check-simulation.js",
          "language": "node",
          "pass_filenames": false,
          "always_run": true
        }
      ]
    }
  ]
}
```

```javascript
// scripts/check-simulation.js
const fs = require('fs');
const path = require('path');

const FORBIDDEN_PATTERNS = [
  /simulated:/i,
  /test.*payment/i,
  /fake.*account/i,
  /mock.*provider/i,
  /demo.*balance/i,
  /placeholder.*\$/i
];

function scanForSimulation() {
  let hasViolations = false;
  
  // Check mission completion notes
  const missionsPath = path.join(__dirname, '../missions/*.json');
  const missions = glob.sync(missionsPath);
  
  missions.forEach(missionFile => {
    const content = fs.readFileSync(missionFile, 'utf8');
    const mission = JSON.parse(content);
    
    if (mission.completion_notes) {
      FORBIDDEN_PATTERNS.forEach(pattern => {
        if (pattern.test(mission.completion_notes)) {
          console.error(`âŒ Simulation artifact in ${missionFile}:`, mission.completion_notes);
          hasViolations = true;
        }
      });
    }
  });
  
  // Check for SBDS violations in earnings
  const earnings = await base44.query({
    entity: 'Earning',
    where: {
      beneficiary: { $not: { $in: SBDS_ALLOWLIST } }
    }
  });
  
  if (earnings.length > 0) {
    console.error(`âŒ ${earnings.length} earnings violate SBDS protocol`);
    hasViolations = true;
  }
  
  if (hasViolations) {
    console.error('ðŸš« Deployment blocked: Simulation artifacts detected');
    process.exit(1);
  }
  
  console.log('âœ… No simulation artifacts found');
}

scanForSimulation();
```

### 4ï¸âƒ£ Implement Idempotency & Replay Protection
This prevents duplicate webhook processing and enforces state monotonicity.

```javascript
// src/webhook-idempotency.mjs
const processedEvents = new Set();

export async function processWebhookWithIdempotency(event) {
  const eventHash = createEventHash(event);
  
  // 1. Reject duplicates
  if (processedEvents.has(eventHash)) {
    console.log(`ðŸ”„ Duplicate webhook ignored: ${event.id}`);
    return { processed: false, reason: 'duplicate' };
  }
  
  // 2. Check monotonic state transitions
  const currentState = await getCurrentPayoutState(event.resource.payout_item_id);
  const newState = mapPayPalStatus(event.event_type);
  
  if (!isValidStateTransition(currentState, newState)) {
    console.error(`âŒ Invalid state transition: ${currentState} â†’ ${newState}`);
    await base44.create('TransactionLog', {
      transaction_type: 'STATE_TRANSITION_VIOLATION',
      description: `Attempted invalid transition ${currentState} â†’ ${newState} for ${event.id}`,
      status: 'rejected'
    });
    return { processed: false, reason: 'invalid_transition' };
  }
  
  // 3. Process and mark as handled
  processedEvents.add(eventHash);
  await base44.create('PayPalWebhookEvent', {
    event_id: event.id,
    event_type: event.event_type,
    created_at: new Date(event.create_time),
    summary: event.summary,
    payload: event,
    hash: eventHash,
    processed_at: new Date()
  });
  
  return { processed: true, hash: eventHash };
}

// State transition validation
const ALLOWED_TRANSITIONS = {
  pending: ['processing', 'success', 'failed', 'unclaimed'],
  processing: ['success', 'failed', 'unclaimed'],
  success: [], // Terminal state
  failed: [], // Terminal state
  unclaimed: ['refunded']
};

function isValidStateTransition(from, to) {
  return ALLOWED_TRANSITIONS[from]?.includes(to) ?? false;
}
```

### 5ï¸âƒ£ Create Release Provenance & Immutable Deployment Records
Every deployment gets a cryptographic fingerprint in Base44.

```javascript
// scripts/create-deployment-record.mjs
import crypto from 'crypto';
import { execSync } from 'child_process';
import { base44 } from '../src/your-base44-client.mjs';

async function createDeploymentRecord() {
  const commitHash = execSync('git rev-parse HEAD').toString().trim();
  const buildTime = new Date().toISOString();
  
  // Create artifact hash
  const files = [
    'package.json',
    'src/emit-revenue-events.mjs',
    'src/paypal-webhook-server.mjs',
    'src/sbds-enforcer.mjs'
  ];
  
  const fileHashes = files.map(file => {
    const content = fs.readFileSync(file);
    return {
      file,
      hash: crypto.createHash('sha256').update(content).digest('hex')
    };
  });
  
  const artifactHash = crypto.createHash('sha256')
    .update(JSON.stringify(fileHashes))
    .digest('hex');
  
  // Store in Base44 for audit trail
  const deploymentId = `deploy-${commitHash.slice(0, 8)}-${Date.now()}`;
  
  await base44.create('TransactionLog', {
    transaction_type: 'SYSTEM_DEPLOYMENT',
    description: `Deployment ${deploymentId}`,
    status: 'completed',
    metadata: {
      deployment_id: deploymentId,
      commit_hash: commitHash,
      artifact_hash: artifactHash,
      build_time: buildTime,
      file_hashes: fileHashes,
      sbds_policy_active: true,
      truth_only_ui_enabled: process.env.BASE44_ENABLE_TRUTH_ONLY_UI === 'true'
    }
  });
  
  console.log(`âœ… Deployment recorded: ${deploymentId}`);
  return deploymentId;
}

// Run on every deployment
createDeploymentRecord();
```

### 6ï¸âƒ£ Final Integration: The "All Good" Dashboard
Create a single command that validates **all** proof-of-life signals.

```bash
#!/bin/bash
# check-all-good.sh - The definitive "is it live?" check

echo "=== EVIDENCE-GATED SYSTEM HEALTH CHECK ==="
echo ""

# 1. Check environment gates
npm run live:readiness

# 2. Check proof of recent activity
echo ""
echo "=== RECENT ACTIVITY PROOF ==="
npm run emit:revenue -- --export-payout-truth --only-real --limit=5

# 3. Check webhook heartbeat
echo ""
echo "=== WEBHOOK HEARTBEAT ==="
curl -s http://localhost:8787/health | jq '.'
curl -s http://localhost:8787/paypal/webhook/events/recent | jq '.'

# 4. Check for simulation artifacts
echo ""
echo "=== SIMULATION AUDIT ==="
npm run emit:revenue -- --report-pending-approval | grep -i "simulated\|demo\|test" && echo "âŒ SIMULATION ARTIFACTS FOUND" || echo "âœ… No simulation artifacts"


# 5. Generate final verdict
echo ""
echo "=== FINAL VERDICT ==="
if [ "$SWARM_LIVE" = "true" ] && \
   [ "$BASE44_ENABLE_TRUTH_ONLY_UI" = "true" ] && \
   [ -f "webhook-log.json" ] && \
   [ $(jq 'length' webhook-log.json) -gt 0 ]; then
  echo "âœ… SYSTEM IS LIVE AND PROVEN"
  echo "   - Gates: ACTIVE"
  echo "   - Truth-only: ENABLED"
  echo "   - Webhooks: FLOWING"
  echo "   - SBDS: ENFORCED"
else
  echo "âš ï¸ SYSTEM NOT FULLY PROVEN"
  echo "   Run: npm run live:setup && deploy-live.bat all"
fi
```

### Execution Plan (30 Minutes to "All Good")

1. **Immediate (5 min)**: Run the health check:
   ```bash
   ./check-all-good.sh > system-health-$(date +%s).txt
   ```

2. **Add Monitoring (10 min)**:
   - Add `deadman-switch.mjs` to your daemon
   - Add `mission-health-monitor.mjs` and schedule hourly runs

3. **Clean Artifacts (5 min)**:
   ```bash
   npm run emit:revenue -- --repair-payout-truth --dry-run
   # Review, then run live
   ```

4. **Deploy Provenance (5 min)**:
   ```bash
   node scripts/create-deployment-record.mjs
   ```

5. **Verify (5 min)**:
   - Check Base44 for new `SYSTEM_DEPLOYMENT` log
   - Run health check again
   - Mission status should now show `events_processed > 0` and `last_*` timestamps

Your system now should have:
1. **Evidence-gated status** (no more green without proof)
2. **Automatic freeze on failure** (dead-man switches)
3. **Simulation artifact blocking** (pre-commit hooks)
4. **Idempotent processing** (no duplicate payments)
5. **Immutable deployment records** (provenance trail)

**"All good" now means**: "The system has processed real transactions, webhooks are flowing, SBDS is enforced, and we have cryptographic proof of all of the above."