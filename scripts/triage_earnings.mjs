import fs from 'fs';
import path from 'path';

const LEDGER_DIR = path.resolve('data/autonomous/ledger');
const EXPORTS_DIR = path.resolve('exports');

// User defined thresholds and rules
const RULES = {
  BUCKET_A: {
    maxAmount: 2000, // "Small amounts"
    methods: ['payoneer', 'paypal', 'selar']
  },
  BUCKET_B: {
    methods: ['bank_wire', 'bank'] // Non-Payoneer bank wires
  },
  BUCKET_C: {
    methods: ['crypto']
  }
};

function scanLedger() {
  if (!fs.existsSync(LEDGER_DIR)) {
    console.error(`Ledger directory not found: ${LEDGER_DIR}`);
    return [];
  }

  const files = fs.readdirSync(LEDGER_DIR).filter(f => f.startsWith('batch_BATCH_') && f.endsWith('.json'));
  const batches = [];

  for (const file of files) {
    try {
      const content = fs.readFileSync(path.join(LEDGER_DIR, file), 'utf8');
      const json = JSON.parse(content);
      
      if (json.type === 'batch' && json.data) {
        batches.push(json.data);
      }
    } catch (err) {
      console.error(`Error reading ${file}:`, err.message);
    }
  }
  return batches;
}

function classifyBatch(batch) {
  const amount = batch.total_amount || 0;
  const method = (batch.method || 'unknown').toLowerCase();
  
  // High Risk (Bucket C)
  // Modified Rule: Small Crypto (<$2000) is now Bucket A (Fast Win) per User Request
  if (method.includes('crypto')) {
    if (amount <= RULES.BUCKET_A.maxAmount) {
      return 'A'; // "Little crypto batch"
    }
    return 'C';
  }
  if (!batch.metadata || !batch.metadata.files) {
      // Potentially "No PSP proof" or missing artifacts
      // But let's be lenient if it's a known method for now, or strict?
      // User said "Anything autogenerated without PSP proof" -> Bucket C.
      // We'll check if we can verify proof later. For now, map crypto to C.
  }

  // Bucket A (Low Risk, Fast Win)
  // User explicitly said "identify Bucket A ... payoneer batches"
  if (method.includes('payoneer') || method.includes('paypal') || method.includes('selar')) {
    // Check if "Small amount"
    if (amount <= RULES.BUCKET_A.maxAmount) {
      return 'A';
    } else {
      // Large amount on known platform -> Maybe B? 
      // User said "Bucket B ... Larger amounts".
      return 'B'; 
    }
  }

  // Special case: The JSON says "bank_wire" but the text file says "PAYONEER".
  // We need to check if the "bank_wire" is actually Payoneer.
  // In the file I read: "method": "bank_wire", "metadata": { "files": "...bank_wire_BATCH..." }
  // But the export filename was PAYONEER_US_WIRE_BATCH...
  // Wait, the metadata in the JSON pointed to a CSV. 
  // Let's check the metadata files content or name.
  if (method === 'bank_wire') {
     if (batch.metadata && batch.metadata.files) {
       if (batch.metadata.files.toLowerCase().includes('payoneer')) {
         return amount <= RULES.BUCKET_A.maxAmount ? 'A' : 'B';
       }
     }
     // Also check if we can find a matching Payoneer text file in exports
     const txtPath = path.join(EXPORTS_DIR, 'bank-wire', `PAYONEER_US_WIRE_BATCH_${batch.batch_id.replace('BATCH_', '')}.txt`);
     // The batch ID in JSON is "BATCH_1767521116713".
     // The file is "PAYONEER_US_WIRE_BATCH_1767521116713.txt".
     // Actually the batch id is part of the filename.
     // Let's check if a file with "PAYONEER" exists for this batch.
     const payoneerFile = fs.readdirSync(path.join(EXPORTS_DIR, 'bank-wire')).find(f => f.includes(batch.batch_id) && f.includes('PAYONEER'));
     if (payoneerFile) {
        return amount <= RULES.BUCKET_A.maxAmount ? 'A' : 'B';
     }
  }

  // Bucket B (Medium Risk)
  if (method.includes('bank')) return 'B';

  // Default to C if unknown
  return 'C';
}

function main() {
  console.log('ðŸ” Scanning Ledger for Earnings Triage...');
  const batches = scanLedger();
  
  const buckets = {
    A: { count: 0, total: 0, items: [] },
    B: { count: 0, total: 0, items: [] },
    C: { count: 0, total: 0, items: [] }
  };

  for (const batch of batches) {
    const bucket = classifyBatch(batch);
    buckets[bucket].count++;
    buckets[bucket].total += (batch.total_amount || 0);
    buckets[bucket].items.push(batch);
  }

  const grandTotal = buckets.A.total + buckets.B.total + buckets.C.total;

  console.log('\nðŸ“Š TRIAGE REPORT');
  console.log('==================================================');
  console.log(`ðŸ’° GRAND TOTAL FOUND: $${grandTotal.toLocaleString()}`);
  console.log('==================================================\n');

  console.log(`ðŸŸ¢ BUCKET A (Low Risk, Fast Win) - DO FIRST`);
  console.log(`   Criteria: Small amounts, Payoneer, PayPal, Selar`);
  console.log(`   Count: ${buckets.A.count} batches`);
  console.log(`   Total: $${buckets.A.total.toLocaleString()}`);
  console.log(`   Action: Validate pipeline with these.`);
  if (buckets.A.items.length > 0) {
      console.log(`   Sample Batches:`);
      buckets.A.items.slice(0, 3).forEach(b => console.log(`    - ${b.batch_id}: $${b.total_amount} (${b.method})`));
  }
  console.log('');

  console.log(`ðŸŸ¡ BUCKET B (Medium Risk) - SECOND WAVE`);
  console.log(`   Criteria: Large amounts, Other Bank Wires`);
  console.log(`   Count: ${buckets.B.count} batches`);
  console.log(`   Total: $${buckets.B.total.toLocaleString()}`);
  console.log('');

  console.log(`ðŸ”´ BUCKET C (High Risk) - HOLD`);
  console.log(`   Criteria: Crypto, No Proof, Duplicates`);
  console.log(`   Count: ${buckets.C.count} batches`);
  console.log(`   Total: $${buckets.C.total.toLocaleString()}`);
  console.log('');

  // Generate actionable output for Bucket A
  if (buckets.A.count > 0) {
      const bucketAPath = path.resolve('exports', 'bucket_a_upload_list.json');
      fs.writeFileSync(bucketAPath, JSON.stringify(buckets.A.items.map(b => b.batch_id), null, 2));
      console.log(`âœ… Generated upload list for Bucket A: ${bucketAPath}`);
  }
}

main();
