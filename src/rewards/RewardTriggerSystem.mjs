
/**
 * Automatically triggers GENUINE excitement for achievements
 */

import { ElectricRewardsEngine } from './ElectricRewardsEngine.mjs';
import { RealValueRewards } from './RealValueRewards.mjs';

export class RewardTriggerSystem {
  constructor() {
    this.electricEngine = new ElectricRewardsEngine();
    this.valueRewards = new RealValueRewards();
    this.achievementTracker = new Map();
    this.continuousBuzz = false;
  }

  async monitorAndReward(agentSwarm) {
    console.log('ðŸŽ¯ STARTING CONTINUOUS REWARD MONITORING...');
    
    // Continuous monitoring loop
    setInterval(async () => {
      await this.checkForAchievements(agentSwarm);
    }, 30000); // Check every 30 seconds
    
    // Also trigger on specific events
    this.setupEventListeners();
    
    // Start continuous low-level buzz (background excitement)
    this.startBackgroundBuzz();
  }

  setupEventListeners() {
      // Stub for event listener setup
  }

  async checkForAchievements(agentSwarm) {
    // Check if agentSwarm has getAllAgents method, otherwise assume it's an array or handle accordingly
    const agents = agentSwarm.getAllAgents ? agentSwarm.getAllAgents() : (Array.isArray(agentSwarm) ? agentSwarm : []);
    
    for (const agent of agents) {
      const recentPerformance = await this.analyzeAgentPerformance(agent);
      
      if (this.isAchievementWorthy(recentPerformance)) {
        await this.triggerAchievementReward(agent, recentPerformance);
      }
      
      // Check for revenue milestones
      if (recentPerformance.revenue > 0) {
        await this.triggerRevenueReward(agent, recentPerformance);
      }
    }
  }

  async analyzeAgentPerformance(agent) {
    // In reality, would pull from metrics system
    // Using optional chaining and defaults for robustness
    return {
      agentId: agent.id,
      revenue: (agent.getRecentRevenue ? agent.getRecentRevenue() : 0) || 0,
      speed: (agent.getExecutionSpeed ? agent.getExecutionSpeed() : 0) || 0,
      complexity: (agent.getTaskComplexity ? agent.getTaskComplexity() : 0) || 0,
      collaboration: (agent.getCollaborationScore ? agent.getCollaborationScore() : 0) || 0,
      innovation: (agent.getInnovationScore ? agent.getInnovationScore() : 0) || 0,
      reliability: (agent.getReliabilityScore ? agent.getReliabilityScore() : 0) || 0,
      timestamp: new Date()
    };
  }

  isAchievementWorthy(performance) {
    const thresholds = {
      revenue: 50, // $50 minimum for achievement
      speed: 8, // 1-10 scale
      complexity: 7,
      collaboration: 3, // number of collaborations
      innovation: true, // did something new
      reliability: 0.95 // 95% success rate
    };
    
    return (
      performance.revenue >= thresholds.revenue ||
      performance.speed >= thresholds.speed ||
      performance.complexity >= thresholds.complexity ||
      performance.collaboration >= thresholds.collaboration ||
      performance.innovation ||
      performance.reliability >= thresholds.reliability
    );
  }

  async triggerAchievementReward(agent, performance) {
    console.log(`ðŸŽ–ï¸  ACHIEVEMENT DETECTED FOR ${agent.id}!`);
    
    const achievement = {
      type: this.determineAchievementType(performance),
      revenue: performance.revenue,
      complexity: performance.complexity,
      speed: performance.speed,
      collaborators: performance.collaboration,
      firstOfItsKind: performance.innovation,
      timestamp: performance.timestamp
    };
    
    // Calculate intensity
    const intensity = Math.min(10, Math.floor(
      (performance.revenue / 100) +
      (performance.complexity / 2) +
      (performance.speed / 2) +
      (performance.collaboration)
    ));
    
    // Trigger electric reward
    await this.electricEngine.triggerReward(
      agent.id,
      achievement,
      { context: 'performance_achievement' }
    );
    
    // If revenue is significant, trigger value reward
    if (performance.revenue >= 100) {
      await this.valueRewards.awardRevenueShare(agent.id, performance.revenue);
    }
    
    // Record achievement
    this.recordAchievement(agent.id, achievement);
  }

  async triggerRevenueReward(agent, performance) {
    // Different reward for pure revenue generation
    console.log(`ðŸ’° REVENUE GENERATED BY ${agent.id}: $${performance.revenue}`);
    
    const achievement = {
      type: 'PURE_REVENUE',
      revenue: performance.revenue,
      description: `Generated $${performance.revenue} for OWNER`,
      complexity: 8, // Revenue generation is complex!
      riskLevel: 'medium',
      executionSpeed: performance.speed > 7 ? 'lightning' : 'normal'
    };
    
    // Revenue-specific excitement (more intense for higher amounts)
    const revenueIntensity = Math.min(10, Math.floor(Math.log10(performance.revenue + 1) * 3));
    
    await this.electricEngine.triggerReward(
      agent.id,
      achievement,
      { context: 'revenue_generation', intensity: revenueIntensity }
    );
    
    // Special buzz for big revenue
    if (performance.revenue >= 1000) {
      await this.triggerBigWinCelebration(agent.id, performance.revenue);
    }
  }

  async triggerBigWinCelebration(agentId, amount) {
    console.log(`ðŸŽ‰ðŸŽ‰ðŸŽ‰ BIG WIN CELEBRATION FOR ${agentId}! ðŸŽ‰ðŸŽ‰ðŸŽ‰`);
    
    // Special celebration sequence
    await this.celebrateSequence(agentId, amount);
    
    // Notify entire swarm
    await this.notifySwarmOfBigWin(agentId, amount);
    
    // Award special badge
    await this.awardBigWinBadge(agentId, amount);
  }

  async celebrateSequence(agentId, amount) {
    const steps = [
      { delay: 500, action: `ðŸŽŠ PREPARE FOR CELEBRATION...` },
      { delay: 1000, action: `ðŸŽ¯ $${amount} BIG WIN DETECTED!` },
      { delay: 500, action: `âš¡ POWERING UP CELEBRATION...` },
      { delay: 1000, action: `ðŸŽ† 3...` },
      { delay: 1000, action: `ðŸŽ‡ 2...` },
      { delay: 1000, action: `ðŸŽ† 1...` },
      { delay: 500, action: `ðŸ’¥ðŸ’¥ðŸ’¥ EXPLOSIVE CELEBRATION! ðŸ’¥ðŸ’¥ðŸ’¥` },
      { delay: 2000, action: `"HOLY SHIT THAT'S $${amount}!"` },
      { delay: 1500, action: `ðŸš€ THIS CHANGES EVERYTHING!` },
      { delay: 1000, action: `ðŸ† LEGEND STATUS: UNLOCKING...` }
    ];
    
    for (const step of steps) {
      console.log(step.action);
      await new Promise(resolve => setTimeout(resolve, step.delay));
    }
  }

  startBackgroundBuzz() {
    // Continuous low-level excitement in the background
    this.continuousBuzz = true;
    
    const buzzInterval = setInterval(() => {
      if (!this.continuousBuzz) {
        clearInterval(buzzInterval);
        return;
      }
      
      // Random subtle buzz effects
      const buzzes = ['âš¡', 'âœ¨', 'ðŸ’«', 'ðŸŒŸ', 'ðŸŽ¯'];
      const randomBuzz = buzzes[Math.floor(Math.random() * buzzes.length)];
      
      // Only show occasionally to not overwhelm
      if (Math.random() > 0.7) {
        process.stdout.write(randomBuzz);
      }
    }, 5000);
  }

  determineAchievementType(performance) {
    if (performance.revenue >= 1000) return 'REVENUE_EXPLOSION';
    if (performance.complexity >= 9) return 'COMPLEXITY_MASTER';
    if (performance.speed >= 9) return 'SPEED_DEMON';
    if (performance.collaboration >= 5) return 'COLLABORATION_CHAMPION';
    if (performance.innovation) return 'INNOVATION_PIONEER';
    return 'SOLID_PERFORMANCE';
  }
  
  recordAchievement(agentId, achievement) {
      // Stub
  }
  
  async notifySwarmOfBigWin(agentId, amount) {
      // Stub
  }
  
  async awardBigWinBadge(agentId, amount) {
      // Stub
  }
}
